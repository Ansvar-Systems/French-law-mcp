#!/usr/bin/env tsx
/**
 * Census-driven LEGI Archive Ingestion for French Law MCP.
 *
 * Reads data/census.json (generated by census.ts) and parses ALL texts
 * from the extracted DILA LEGI open data archive. Produces seed JSON
 * files in data/seed/ and updates census.json with ingestion results.
 *
 * This is the FULL CORPUS ingestion â€” not limited to a handful of codes.
 *
 * Data source: https://echanges.dila.gouv.fr/OPENDATA/LEGI/
 * Licence: Licence Ouverte v2.0
 *
 * Usage:
 *   npm run ingest:legi                        # Full census-driven ingestion
 *   npm run ingest:legi -- --archive /path.tgz # Use specific archive
 *   npm run ingest:legi -- --extracted /path    # Use already-extracted directory
 *   npm run ingest:legi -- --codes-only         # Only ingest codes (skip TNC)
 *   npm run ingest:legi -- --limit 10           # Limit number of texts to ingest
 */

import * as fs from 'fs';
import * as path from 'path';
import { execFileSync } from 'child_process';
import { fileURLToPath } from 'url';
import { parseLegiXml } from './lib/parser.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const SEED_DIR = path.resolve(__dirname, '../data/seed');
const DATA_DIR = path.resolve(__dirname, '../data');
const CENSUS_PATH = path.join(DATA_DIR, 'census.json');
const ARCHIVE_URL = 'https://echanges.dila.gouv.fr/OPENDATA/LEGI/Freemium_legi_global_20250713-140000.tar.gz';

// ---------------------------------------------------------------------------
// Census types
// ---------------------------------------------------------------------------

interface CensusLaw {
  id: string;
  title: string;
  title_en: string | null;
  identifier: string;        // LEGITEXT or JORFTEXT ID
  url: string | null;
  status: string;
  category: string;
  classification: string;
  classification_reason: string;
  ingested: boolean;
  provision_count: number;
  ingestion_date: string | null;
}

interface CensusFile {
  schema_version: string;
  jurisdiction: string;
  jurisdiction_name: string;
  portal: string;
  census_date: string;
  agent: string;
  summary: {
    total_laws: number;
    total_provisions: number;
    ingestable: number;
    ocr_needed: number;
    inaccessible: number;
    excluded: number;
  };
  laws: CensusLaw[];
}

// ---------------------------------------------------------------------------
// CLI
// ---------------------------------------------------------------------------

interface CliArgs {
  archive?: string;
  extracted?: string;
  codesOnly: boolean;
  limit?: number;
}

function parseArgs(): CliArgs {
  const args = process.argv.slice(2);
  let archive: string | undefined;
  let extracted: string | undefined;
  let codesOnly = false;
  let limit: number | undefined;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--archive' && args[i + 1]) { archive = args[i + 1]; i++; }
    else if (args[i] === '--extracted' && args[i + 1]) { extracted = args[i + 1]; i++; }
    else if (args[i] === '--codes-only') { codesOnly = true; }
    else if (args[i] === '--limit' && args[i + 1]) { limit = parseInt(args[i + 1], 10); i++; }
  }
  return { archive, extracted, codesOnly, limit };
}

// ---------------------------------------------------------------------------
// LEGI archive helpers
// ---------------------------------------------------------------------------

function legiIdToPath(id: string): string {
  const digits = id.replace(/^(LEGITEXT|JORFTEXT)/, '');
  const pairs = [];
  for (let i = 0; i < 10; i += 2) {
    pairs.push(digits.slice(i, i + 2));
  }
  const pathPairs = pairs.join('/');

  if (id.startsWith('LEGITEXT')) {
    return `legi/global/code_et_TNC_en_vigueur/code_en_vigueur/LEGI/TEXT/${pathPairs}/${id}`;
  } else {
    return `legi/global/code_et_TNC_en_vigueur/TNC_en_vigueur/JORF/TEXT/${pathPairs}/${id}`;
  }
}

function walkXmlFiles(dir: string): string[] {
  const results: string[] = [];
  if (!fs.existsSync(dir)) return results;
  const walk = (d: string) => {
    let entries;
    try { entries = fs.readdirSync(d, { withFileTypes: true }); } catch { return; }
    for (const entry of entries) {
      const fp = path.join(d, entry.name);
      if (entry.isDirectory()) walk(fp);
      else if (entry.name.endsWith('.xml') && entry.name.startsWith('LEGIARTI')) results.push(fp);
    }
  };
  walk(dir);
  return results;
}

// ---------------------------------------------------------------------------
// Parse a single text from the extracted archive
// ---------------------------------------------------------------------------

interface ParsedProvision {
  provision_ref: string;
  chapter?: string;
  section: string;
  title: string;
  content: string;
}

interface ParsedLaw {
  documentId: string;
  title: string;
  titleEn: string | null;
  shortName: string | null;
  status: string;
  url: string | null;
  description: string | null;
  provisions: ParsedProvision[];
}

function parseTextDirectory(textDir: string, censusEntry: CensusLaw): ParsedLaw {
  const articleFiles = walkXmlFiles(textDir);

  const provisions: ParsedProvision[] = [];
  let skipped = 0;

  for (const xmlFile of articleFiles) {
    try {
      const xmlContent = fs.readFileSync(xmlFile, 'utf-8');
      const result = parseLegiXml(xmlContent);

      for (const article of result.articles) {
        if (article.content.trim().length === 0) continue;
        provisions.push({
          provision_ref: `art${article.normalizedNum}`,
          section: article.normalizedNum,
          title: article.title,
          content: article.content,
        });
      }
      if (result.articles.length === 0) skipped++;
    } catch {
      skipped++;
    }
  }

  // Deduplicate by provision_ref (keep longest content)
  const byRef = new Map<string, ParsedProvision>();
  for (const prov of provisions) {
    const existing = byRef.get(prov.provision_ref);
    if (!existing || prov.content.length > existing.content.length) {
      byRef.set(prov.provision_ref, prov);
    }
  }
  const deduped = Array.from(byRef.values());
  deduped.sort((a, b) => a.provision_ref.localeCompare(b.provision_ref, 'fr', { numeric: true }));

  return {
    documentId: censusEntry.id,
    title: censusEntry.title,
    titleEn: censusEntry.title_en,
    shortName: null,
    status: censusEntry.status,
    url: censusEntry.url,
    description: null,
    provisions: deduped,
  };
}

// ---------------------------------------------------------------------------
// Seed writers
// ---------------------------------------------------------------------------

function writeSeed(law: ParsedLaw): void {
  fs.mkdirSync(SEED_DIR, { recursive: true });
  const seed = {
    id: law.documentId,
    type: 'statute',
    title: law.title,
    title_en: law.titleEn,
    short_name: law.shortName,
    status: law.status === 'repealed' ? 'repealed' : law.status === 'amended' ? 'amended' : 'in_force',
    url: law.url,
    description: law.description,
    provisions: law.provisions,
  };
  const fp = path.join(SEED_DIR, `${law.documentId}.json`);
  fs.writeFileSync(fp, JSON.stringify(seed, null, 2), 'utf-8');
}

function writeEuReferences(): void {
  const euData = {
    eu_documents: [
      { id: 'regulation:2016/679', type: 'regulation', year: 2016, number: 679, community: 'EU', celex_number: '32016R0679', title: 'General Data Protection Regulation (GDPR)', short_name: 'GDPR', url_eur_lex: 'https://eur-lex.europa.eu/eli/reg/2016/679/oj', in_force: true },
      { id: 'directive:2022/2555', type: 'directive', year: 2022, number: 2555, community: 'EU', celex_number: '32022L2555', title: 'NIS 2 Directive', short_name: 'NIS 2', url_eur_lex: 'https://eur-lex.europa.eu/eli/dir/2022/2555', in_force: true },
      { id: 'directive:2016/1148', type: 'directive', year: 2016, number: 1148, community: 'EU', celex_number: '32016L1148', title: 'NIS 1 Directive', short_name: 'NIS 1', url_eur_lex: 'https://eur-lex.europa.eu/eli/dir/2016/1148', in_force: false },
      { id: 'directive:2013/40', type: 'directive', year: 2013, number: 40, community: 'EU', celex_number: '32013L0040', title: 'Cybercrime Directive', short_name: 'Cybercrime Directive', url_eur_lex: 'https://eur-lex.europa.eu/eli/dir/2013/40', in_force: true },
      { id: 'regulation:2019/881', type: 'regulation', year: 2019, number: 881, community: 'EU', celex_number: '32019R0881', title: 'Cybersecurity Act', short_name: 'Cybersecurity Act', url_eur_lex: 'https://eur-lex.europa.eu/eli/reg/2019/881', in_force: true },
      { id: 'regulation:2024/1689', type: 'regulation', year: 2024, number: 1689, community: 'EU', celex_number: '32024R1689', title: 'EU AI Act', short_name: 'AI Act', url_eur_lex: 'https://eur-lex.europa.eu/eli/reg/2024/1689', in_force: true },
      { id: 'regulation:2022/2554', type: 'regulation', year: 2022, number: 2554, community: 'EU', celex_number: '32022R2554', title: 'Digital Operational Resilience Act (DORA)', short_name: 'DORA', url_eur_lex: 'https://eur-lex.europa.eu/eli/reg/2022/2554', in_force: true },
      { id: 'directive:2002/58', type: 'directive', year: 2002, number: 58, community: 'EU', celex_number: '32002L0058', title: 'ePrivacy Directive', short_name: 'ePrivacy Directive', url_eur_lex: 'https://eur-lex.europa.eu/eli/dir/2002/58', in_force: true },
    ],
    eu_references: [
      { source_type: 'document', source_id: 'code-penal', document_id: 'code-penal', eu_document_id: 'directive:2013/40', reference_type: 'implements', is_primary_implementation: true, implementation_status: 'complete', reference_context: 'Articles 323-1 to 323-7 implement the Cybercrime Directive requirements for criminalizing illegal access, system interference, and data interference.' },
      { source_type: 'document', source_id: 'loi-informatique-libertes', document_id: 'loi-informatique-libertes', eu_document_id: 'regulation:2016/679', reference_type: 'supplements', is_primary_implementation: true, implementation_status: 'complete', reference_context: 'The Loi Informatique et Libertes was extensively amended in 2018 to supplement the GDPR.' },
      { source_type: 'document', source_id: 'code-defense', document_id: 'code-defense', eu_document_id: 'directive:2016/1148', reference_type: 'implements', is_primary_implementation: true, implementation_status: 'complete', reference_context: 'The OIV framework (Articles L. 1332-1 et seq.) predates and exceeds NIS 1 requirements.' },
      { source_type: 'document', source_id: 'code-postes-telecom', document_id: 'code-postes-telecom', eu_document_id: 'directive:2002/58', reference_type: 'implements', is_primary_implementation: false, implementation_status: 'complete', reference_context: 'Telecommunications data retention and security provisions implement ePrivacy Directive requirements.' },
      { source_type: 'document', source_id: 'code-monetaire-et-financier', document_id: 'code-monetaire-et-financier', eu_document_id: 'regulation:2022/2554', reference_type: 'implements', is_primary_implementation: false, implementation_status: 'partial', reference_context: 'Financial sector provisions support DORA implementation for ICT risk management.' },
    ],
  };
  const fp = path.join(SEED_DIR, 'eu-references.json');
  fs.writeFileSync(fp, JSON.stringify(euData, null, 2), 'utf-8');
  console.log(`Wrote EU references: ${fp}`);
}

function writeManualSeeds(): void {
  const seeds = [
    {
      id: 'loi-programmation-militaire-cyber', type: 'statute',
      title: "Loi n\u00b0 2023-703 du 1er ao\u00fbt 2023 relative \u00e0 la programmation militaire 2024-2030",
      title_en: 'Military Programming Law 2024-2030 (cyber provisions)',
      short_name: 'LPM 2024-2030 (cyber)', status: 'in_force',
      issued_date: '2023-08-01', in_force_date: '2023-08-02',
      url: 'https://www.legifrance.gouv.fr/jorf/id/JORFTEXT000047914986',
      description: 'Expands ANSSI powers for cyber threat detection and response.',
      provisions: [
        { provision_ref: 'art64', chapter: 'Chapitre V', section: '64', title: 'Article 64 - ANSSI DNS threat blocking', content: "Lorsqu'il est constat\u00e9 qu'une menace susceptible de porter atteinte \u00e0 la s\u00e9curit\u00e9 nationale r\u00e9sulte de l'exploitation d'un nom de domaine, l'autorit\u00e9 nationale en mati\u00e8re de s\u00e9curit\u00e9 des syst\u00e8mes d'information peut demander \u00e0 toute personne concourant \u00e0 l'adressage par noms de domaine sur internet de prendre les mesures les plus adapt\u00e9es pour neutraliser cette menace." },
        { provision_ref: 'art65', chapter: 'Chapitre V', section: '65', title: 'Article 65 - Extended data collection for ANSSI', content: "Pour les besoins de la s\u00e9curit\u00e9 des syst\u00e8mes d'information, l'autorit\u00e9 nationale en mati\u00e8re de s\u00e9curit\u00e9 des syst\u00e8mes d'information peut mettre en oeuvre des dispositifs mettant en oeuvre des marqueurs techniques aux seules fins de d\u00e9tecter des \u00e9v\u00e9nements susceptibles d'affecter la s\u00e9curit\u00e9 des syst\u00e8mes d'information." },
        { provision_ref: 'art66', chapter: 'Chapitre V', section: '66', title: 'Article 66 - Vulnerability disclosure coordination', content: "L'autorit\u00e9 nationale en mati\u00e8re de s\u00e9curit\u00e9 des syst\u00e8mes d'information peut imposer aux op\u00e9rateurs de communications \u00e9lectroniques la mise en oeuvre de mesures de filtrage de noms de domaine utilis\u00e9es par un attaquant." },
      ],
    },
    {
      id: 'nis2-transposition-france', type: 'statute',
      title: 'Cadre de transposition de la directive NIS 2 en droit fran\u00e7ais',
      title_en: 'Framework for NIS 2 Directive transposition into French law',
      short_name: 'NIS 2 FR transposition', status: 'not_yet_in_force',
      url: 'https://cyber.gouv.fr/la-directive-nis-2',
      description: "France's transposition of NIS 2 Directive.",
      provisions: [
        { provision_ref: 'art-scope', section: 'scope', title: 'Scope - Essential and Important Entities', content: "La transposition NIS 2 distingue les 'entit\u00e9s essentielles' (EE) et les 'entit\u00e9s importantes' (EI)." },
        { provision_ref: 'art-notification', section: 'notification', title: "Notification d'incidents", content: "Alerte pr\u00e9coce dans les 24h, notification compl\u00e8te dans les 72h, rapport final dans un mois." },
        { provision_ref: 'art-measures', section: 'measures', title: 'Mesures de gestion des risques', content: "Mesures techniques, op\u00e9rationnelles et organisationnelles appropri\u00e9es." },
        { provision_ref: 'art-sanctions', section: 'sanctions', title: 'Sanctions', content: "EE: jusqu'\u00e0 10M EUR ou 2% CA. EI: 7M EUR ou 1,4% CA." },
      ],
    },
  ];
  for (const seed of seeds) {
    const fp = path.join(SEED_DIR, `${seed.id}.json`);
    fs.writeFileSync(fp, JSON.stringify(seed, null, 2), 'utf-8');
    console.log(`Wrote manual seed: ${fp} (${seed.provisions.length} provisions)`);
  }
}

// ---------------------------------------------------------------------------
// Archive download + extraction
// ---------------------------------------------------------------------------

function ensureArchive(archivePath: string): void {
  if (fs.existsSync(archivePath)) {
    const size = fs.statSync(archivePath).size;
    console.log(`Using existing archive: ${archivePath} (${(size / 1024 / 1024).toFixed(0)}MB)`);
    return;
  }

  console.log(`Downloading LEGI archive from ${ARCHIVE_URL}...`);
  execFileSync('curl', ['-fSL', '--progress-bar', '-o', archivePath, ARCHIVE_URL], {
    stdio: 'inherit',
    timeout: 1_800_000,
  });
  console.log('Download complete.');
}

function ensureExtracted(archivePath: string, extractDir: string): void {
  if (fs.existsSync(path.join(extractDir, 'legi'))) {
    console.log(`Using previously extracted archive at ${extractDir}`);
    return;
  }

  if (fs.existsSync(extractDir)) {
    execFileSync('rm', ['-rf', extractDir]);
  }
  fs.mkdirSync(extractDir, { recursive: true });

  console.log(`Extracting archive to ${extractDir}...`);
  console.log('This extracts ~10GB, takes 2-5 minutes...');
  execFileSync('tar', ['xzf', archivePath, '-C', extractDir], {
    timeout: 1_200_000,
    maxBuffer: 50 * 1024 * 1024,
    stdio: 'inherit',
  });
  console.log('Extraction complete.');
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main(): Promise<void> {
  const { archive, extracted, codesOnly, limit } = parseArgs();

  console.log('=== French Law MCP \u2014 Census-Driven LEGI Ingestion ===\n');

  // Load census
  if (!fs.existsSync(CENSUS_PATH)) {
    console.error(`Census file not found: ${CENSUS_PATH}`);
    console.error('Run census first: npx tsx scripts/census.ts');
    process.exit(1);
  }

  const census: CensusFile = JSON.parse(fs.readFileSync(CENSUS_PATH, 'utf-8'));
  console.log(`Census loaded: ${census.laws.length} texts`);

  // Filter to ingestable texts.
  // Default: codes + lois + ordonnances (primary legislation)
  // --codes-only: only codes
  // --all: everything including decrets and arretes
  let targets = census.laws.filter(l => l.classification === 'ingestable');
  if (codesOnly) {
    targets = targets.filter(l => l.category === 'code');
    console.log(`Codes-only mode: ${targets.length} codes`);
  } else {
    // Default: codes + lois + ordonnances (primary consolidated legislation)
    const PRIMARY_CATEGORIES = new Set(['code', 'loi', 'ordonnance']);
    targets = targets.filter(l => PRIMARY_CATEGORIES.has(l.category));
    console.log(`Primary legislation mode: ${targets.length} texts (codes + lois + ordonnances)`);
  }
  if (limit) {
    targets = targets.slice(0, limit);
    console.log(`Limited to ${limit} texts`);
  }

  console.log(`Texts to ingest: ${targets.length}\n`);

  // Ensure archive is available
  let extractDir: string;
  if (extracted) {
    extractDir = extracted;
    console.log(`Using pre-extracted directory: ${extractDir}`);
  } else {
    const archivePath = archive ?? '/tmp/legi_global.tar.gz';
    ensureArchive(archivePath);
    extractDir = '/tmp/legi_extracted';
    ensureExtracted(archivePath, extractDir);
  }

  // Clear old seed files (except eu-references.json)
  if (fs.existsSync(SEED_DIR)) {
    const oldFiles = fs.readdirSync(SEED_DIR).filter(f =>
      f.endsWith('.json') && f !== 'eu-references.json'
    );
    for (const f of oldFiles) {
      fs.unlinkSync(path.join(SEED_DIR, f));
    }
    console.log(`Cleared ${oldFiles.length} old seed files`);
  }
  fs.mkdirSync(SEED_DIR, { recursive: true });

  // Ingest each text
  const results: Array<{ id: string; provisions: number }> = [];
  let totalProvisions = 0;
  let processed = 0;
  let skippedEmpty = 0;

  for (const entry of targets) {
    processed++;

    // Compute directory path from the LEGITEXT/JORFTEXT identifier
    const textDir = path.join(extractDir, legiIdToPath(entry.identifier));

    if (!fs.existsSync(textDir)) {
      if (processed <= 20 || processed % 100 === 0) {
        console.log(`  [${processed}/${targets.length}] SKIP ${entry.id}: directory not found`);
      }
      skippedEmpty++;
      continue;
    }

    const law = parseTextDirectory(textDir, entry);

    if (law.provisions.length === 0) {
      skippedEmpty++;
      continue;
    }

    writeSeed(law);
    results.push({ id: law.documentId, provisions: law.provisions.length });
    totalProvisions += law.provisions.length;

    // Update census entry
    entry.ingested = true;
    entry.provision_count = law.provisions.length;
    entry.ingestion_date = new Date().toISOString().split('T')[0];

    if (processed % 50 === 0 || processed === targets.length) {
      console.log(`  [${processed}/${targets.length}] ${entry.id}: ${law.provisions.length} provisions (running total: ${totalProvisions})`);
    }
  }

  // Write EU references and manual seeds
  writeEuReferences();
  writeManualSeeds();

  // Update census with ingestion results
  census.summary.total_provisions = totalProvisions;
  fs.writeFileSync(CENSUS_PATH, JSON.stringify(census, null, 2), 'utf-8');
  console.log(`\nUpdated census: ${CENSUS_PATH}`);

  // Summary
  console.log('\n=== Ingestion Summary ===');
  console.log(`Processed: ${processed} texts`);
  console.log(`Ingested: ${results.length} texts with provisions`);
  console.log(`Skipped (empty/missing): ${skippedEmpty}`);
  console.log(`Total provisions: ${totalProvisions}`);

  // Top 10 largest
  results.sort((a, b) => b.provisions - a.provisions);
  console.log('\nTop 10 largest:');
  for (const r of results.slice(0, 10)) {
    console.log(`  ${r.id}: ${r.provisions} provisions`);
  }

  console.log('\n+ 2 manual seeds (LPM 2024-2030 cyber, NIS 2 transposition)');
  console.log('\nNext step: npm run build:db');
}

main().catch(err => {
  console.error('LEGI ingestion failed:', err);
  process.exit(1);
});
